# 整理高频面试题

## 浏览器

### 输入一个URL到页面过程中发生了什么
+ 首先在浏览器中输入URL
+ 查找缓存：浏览器先查看缓存，如果有则显示内容。没有进行下一步
+ DNS域名解析：浏览器向DNS服务器发送请求，解析该URL中的域名对应的IP地址。
+ 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
+ 发起HTTP请求：浏览器发起读取文件的HTTP请求
+ 服务器响应请求并返回结果
+ 关闭TCP连接
+ 浏览器渲染
    + 构建DOM树：词法分析然后解析成DOM树，树的根是document对象
    + 构建CSS规则树：生成CSS规则树
    + 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树
    + 布局：计算出每个节点在屏幕中的位置
    + 绘制：遍历render树，绘制节点

### 优化项目
+ 缓存利用：javacript和css文件缓存（添加exprise和etag）
+ 请求数量：合并样式和脚本文件、使用精灵图、首屏之外的文件按需加载
+ 请求带宽：压缩文件开启GZIP
+ CSS代码：避免使用css表达式、高级选择器、通配选择器
+ JavaScript代码：减少DOM操作次数
+ HTML代码：图片src属性为空、html中写style属性

## JavaScript

### new运算符实现机制
+ 首先创建一个新的空对象
+ 设置原型，将对象的原型设置为函数的prototype对象
+ 让函数的this指向这个对象，指向构造函数
+ 返回创建的对象

### 作用域链
变量取值到创建这个变量的函数作用域中取值，但是如果在当前作用域中没有查到值，就会到上级作用域去查，直到查到全局作用域，这个查找的过程形成的链条就叫做作用域链。

### 执行上下文
【定义】函数执行前的准备工作
【简介】运行JavaScript代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等

+ JavaScript执行环境分为全局环境和函数环境，因此对应的执行上下文分为全局执行上下文和函数执行上下文。
+ 函数编程中，代码中会声明多个函数，对应的执行上下文也会存在多个。在JavaScript中通过栈的存取方式来管理执行上下文，我们可称其为执行栈，或函数调用栈（Call Stack）
+ 执行上下文的生命周期
    
    + 创建阶段
        + 创建变量对象（Arguments对象声明、函数声明、函数表达式声明）
        + 确定this指向
        + 确定作用域
    + 执行阶段 
        + 变量对象赋值
        + 调用函数
        + 顺序执行其他代码

### 原型和原型链
+ 原型
    + 每个class都有显示原型prototype
    + 每个实例都有隐式原型__proto__
    + 实例的__proto__指向对应class的prototype
+ 原型链：当我们访问一个对象属性时，如果这个对象内部不存在这个属性，那么他就会去它的原型对象中找这个属性。这个原型对象又有自己的原型，于是就这样一直找下去，也就是原型链的概念。

### 闭包
+ 定义：闭包是指有权访问另一个函数作用域中的变量的函数
+ 闭包形成条件
    + 函数的嵌套
    + 内部函数引用外部函数的局部变量，延长外部函数的变量生命周期
+ 闭包用途
    + 私有化变量
    + 模拟块级作用域
    + 创建模块
+ 缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

### 防抖节流
防抖：n秒后在执行该事件，若在n秒内被重复出发，则重新计时

节流：n秒内只运行一次，若在n秒内重复出发，只有一次生效

### CommonJs和ESModule的区别
+ 导入导出语法不同
+ commonjs是运行时加载模块，ESModule是在静态编译期间就确定模块依赖
+ ESModule在编译期间会将所有import提升到顶部，commonjs不会提升到顶部
+ commonjs导出的是一个值拷贝，ESModule导出的是一个引用
+ commonjs中顶层的this指向这个模块本身，而ESModule中顶层this指向undefined
+ commonjs加载的是整个模块，将所有接口全部加载进来，而ESModule可以单独加载某个接口（是否能tree shaking的原因）

### 用过哪些ES6新特性
+ 变量声明
+ 块级作用域
+ 允许参数设置默认值
+ 解构赋值
+ 扩展运算符
+ 模版字符串
+ 箭头函数
+ promise
+ async/await
+ 迭代器iterator

## 箭头函数和普通函数的区别
+ 书写上的区别：箭头函数比普通函数更加简洁
+ 参数上的区别：普通函数的参数是arguments，箭头函数是args
+ this的指向不同：箭头函数的this指向上层函数作用域this对象，如果没有上层函数作用域，则指向window，普通函数this指向该函数的调用者
+ 原型和构造函数：箭头函数不能使用new生成实例，因为箭头函数没有prototype
+ 对es6使用的限制：箭头函数内不能用yield且不能用作Generator函数，而普通函数可以。

## 事件循环
由于javascript是单线程。单线程意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不等着，于是js的任务分两种：同步任务和异步任务，同步任务调用就会得到结果，而异步任务无法立即得到结果，将它放入到任务队列，等到执行完同步任务后，再去任务队列中去处理异步任务的返回结果。

## 宏任务和微任务
+ 宏任务：script代码、setTimeout、setInterval、I/O、UI Rendering
+ 微任务：Process.nextTick、promise、MutationObserver

## React

### React生命周期
从React实例创建、运行、到销毁期间，伴随着各种事件，这些事件统称为生命周期。
+ constructor
+ getDerivedStateFromProps
+ render
+ componentDidMount
+ shouldComponentUpdate
+ getSnapshotBeforeUpdate
+ componentDidUpdate
+ componentWillUnmount

### :key
作用是：在diff算法中判断元素是最新创建的还是被移动来的，从而减少不必要的diff，也就是提高diff同级比较的效率

react中的key属性，它是一个特殊的属性，它是出现不是给开发者用的，而是给React自己使用，有了key属性后，就可以与组件建立了一种对应关系，react利用key来识别组件，他是一种身份标识。每个key 对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。在render函数执行的时候，新旧两个虚拟DOM会进行对比，如果两个元素有不同的key，那么在前后两次渲染中就会被认为是不同的元素，这时候旧的那个元素会被销毁，新的元素会被创建。如果提供了唯一的标识key且是相同的key，且元素类型相同， 若元素属性有所变化，则React只更新组件对应的属性，这种情况下，性能开销会相对较小。

### 受控组件和非受控组件
+ 受控组件：状态由开发者维护（value，onchange中setState更新状态）
+ 非受控组件：状态由自身维护（通过ref类似获取DOM的行为）

### React合成事件
React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，在React中这套事件机制被称之为合成事件。
与原生事件直接在元素上注册的方式不同的是，React的合成事件不会直接绑定到目标DOM节点上，用事件委托机制，以队列的方式，从触发事件的组件向父组件回溯，直到Root节点

合成事件的优点
+ 兼容各种主流浏览器的DOM事件（类似jquery兼容各个浏览器DOM api）
+ 减少内存消耗，提升性能，不需要注册那么多事件，一种事件类型只在Root上注册一次 

合成事件和原生事件的区别
+ 事件名称命名方式不同（原生：纯小写、合成事件：驼峰）
+ 事件处理函数写法不同（原生事件处理函数为字符串，合成事件传入函数作为事件处理函数）
+ 阻止默认行为方式不同（原生：return false，合成事件：e.prevDefault()）

### 为什么 hooks 不能写在循环或者条件判断语句里？
函数本身不能保存状态，我们需要额外维护一个有序的表，在执行 setState 之类的 hook 时，将它们保存到这个表里。
这要求每次函数组件的 hook 执行的位置相同，数量正确，否则会导致错位，不能拿到预期的状态值。

### React生命周期为什么做调整
+ React v16之前是同步渲染的，v16之后是异步渲染的，在render函数之前的所有函数可能被执行多次
+ 原有生命周期会诱惑开发者在render之前的生命周期函数中做一些动作，这些动作还放在这些函数中的话，有可能会被调用多次

注：使用异步渲染后，带有will的生命周期都不能保证更新只调用一次，所以废弃（componentWillMount,componentWillUpdate,componentWillUnmount）

### 父组件调用子组件方法
+ 父组件定义方法接受一个参数
+ 通过props传递到子组件
+ 子组件在componentDidMount中调用传入方法，并且传入子组件this

### React项目优化
+ 添加key值
+ shouldComponentUpdate生命周期优化不需要重新更新的组件

### React中保存页面状态
+ 手动保存状态：componentWillUnmount通过redux保存数据，componentDidMount恢复数据
+ 通过样式控制：列表和详情页在同一个页面，通过样式来控制显示与隐藏
+ 自动保存状态：实现类似vue的keepAlive（react-activation）


### 常见的hooks
常见的hooks：简单的特殊函数实现class的各种功能，让你在不编写类的情况下使用state和其他React特性
+ State Hook 维护state状态
+ Effect Hook 书写一些组件的副作用ajax请求
+ Ref Hook 操作DOM
+ Memo Hook 缓存组件状态
+ Callback Hook 缓存方法

### 持久化Redux状态
react-persist

### React长列表多优化
展示大型列表和表格数据，如城市列表和通讯录，会导致页面不流畅、卡顿等性能问题。

+ 懒加载：每次只加载一部分数据，加载更多时再渲染一部分数据
    + 优点：每次渲染一部分数据，数据快
    + 缺点：等数据量加载到非常多时，页面依然存在大量DOM节点
+ react-virtualized：只渲染可视区域节点

### React Fiber
在数据更新时，react生成了一棵更大的虚拟dom树，给第二步的diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。js占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了react fiber。

react fiber没法让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上

### hash和history模式的区别
hash就是url中#以及后面的字符，改变hash值不会向后端发送请求，不会重新加载页面hash不需要服务器配置

history以/开头，当history发生改变时会重新加载页面，服务器配置回调路由

hash通过监听浏览器onhashchange事件变化，查找对应路由应用。通过改变location.hash改变页面路由

history利用pushState和replaceState方法改变页面路径

## Webpack

### 什么是webpack
webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好的管理、打包开发中所用到的HTML、CSS、Javascript和静态资源等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且分析模块间的依赖关系，最后合并生成优化的静态资源。

+ 代码转换：TypeScript编译成JavaScript，SCSS编译成CSS等
+ 文件优化：压缩JavaScript、CSS、HTML代码
+ 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
+ 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
+ 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器

### loader和plugin的区别
loader：是用来告诉webpack如何转化某一类型的文件，并且引入到打包的文件中
plugin：可以打包优化，资源管理和注入环境变量